## Библиотека для отправки данных по TCP

Суть использования сводится к тому, что на каждую функцию, которая работает непосредственно с сокетом (пишет, читает, соединяется) нужно вызывать функцию (лучше всего раз в 100-300мс), которая будет проверять завершилась ли предыдущая. Это вынужденная мера, так как киппер не умеет работать с дллкой в многопотоке

## Возможности и фичи

1. Поддержка всех видов проксей (socks4, socks5, http)
2. Поддержка tls over tcp
3. Возможность ресолвить айпишик хоста как локально, так и отдавая сам хост проксе (второе это socks5h и socks4a)
4. Возможность изменения таймаута в процессе работы (на чтение/запись по отдельности)
5. Чтение n количества байтов
6. Чтение сообщения пока не найдет указанную строку/символ
7. Чтение до конца или же пока не сработает timeout

## Примеры использования

1. Для начала нужно подключится по айпишнику/хосту
   - `|DV|[host]` - собственно наша цель для подключения, домен + порт либо же айпи + порт
   - `|DV|[proxy]` - прокси, всегда ставим |PROXY|
   - `|DV|[timeout]` - таймаут на подключение к проксе, он же и таймаут на чтение/запись
   - `|DV|[proxy_resolve]` - хотим ли, чтобы прокси сам находил айпишник по домену, если false то DNS запрос будет сделан на вашей стороне
   - `|DV|[use_tls]` - использовать ли TLS
   - `|DV|[connection_id]` - айди подключения
```
|DV|[host] = ipify.org:443
|DV|[proxy] = |PROXY|
|DV|[timeout] = 4000
|DV|[proxy_resolve] = true
|DV|[use_tls] = true

|DV|[connection_id] = (|DLL|dllName:tcp;funcName:connect_ip;params:ipify.org:443|PDEL||PROXY||PDEL|4000|PDEL|false|PDEL|true;|DLL|)
```

2. Теперь проверяем получилось ли подключится. Если результат WAIT - подключение в процессе, нужно попробовать еще раз через несколько сотен мс.
Если ошибка - кидаем в капчу (в ошибки соединения кинуть нельзя)

```
(|SLEEP|100|SLEEP|)
|DV|[result] = (|DLL|dllName:tcp;funcName:task_status;params:|PARS|[1];|DLL|)

|||DV|[result]|=|WAIT
(|REPEAT||REPEAT|)

||ERR|pos>0||DV|[result]
|CONCLUSION| = 3
```

3. Теперь отправим http запрос
    - `|DV|[req]` - наш запрос, чтобы его отправить нужно сначала закодировать в base64
    - `|DV|[result]` - хорошим результатом будет ответ `THREAD_SPAWNED`
```
#beginScript
|DV|[req] = GET / HTTP/1.1
Host: ipify.org
User-Agent: curl/7.79.1
Accept: */*


#endScript

|DV|[req_base64] = (|BASE64||DV|[req]|BASE64|)
|DV|[result] = (|DLL|dllName:tcp;funcName:send_data;params:|DV|[connection_id]|PDEL||DV|[req_base64];|DLL|)
```

4. Повторяем 2 пункт, но теперь нужно отключится от сервера, если получили ошибку из функции `task_status`

```
(|DLL|dllName:tcp;funcName:disconnect;params:|DV|[connection_id];|DLL|)
```

5. Получаем (читаем) данные, которые вернул сервер. Результат `THREAD_SPAWNED`
   1. `recv_exact` - передаем connection_id и колличество байтов, которое хотим прочитать
   2. `recv_until` - читаем пока не найдем строку, второй аргумент - строка
   3. `recv_end` - читаем до конца пока не найдем EOF или пока не сработает timeout

```
|DV|[result] = (|DLL|dllName:tcp;funcName:recv_end;params:|PARS|[1];|DLL|)
```
6. Опять таки повторяем пункт 2, теперь если все прошло нормально прочитанный ответ будет в `|DV|[result]` в base64

7. В конце обязательно отключаемся

```
(|DLL|dllName:tcp;funcName:disconnect;params:|DV|[connection_id];|DLL|)
```

## Ремарки и возможные баги

- ~~Иногда случаются вылеты, ищу ошибку~~ (ps. уже нашел - исправил)
- Нельзя делать несколько запросов отправки/чтения данных подряд, то есть send_data -> send_data, так нельзя. А send_data -> task_status -> send_data -> task_status, так можно
- `recv_end` - может сильно замедлять брут
- 150 потоков в киппере = 300 реальных
- Если решили удалить дллку, нельзя это делать сразу после закрытия проекта, в котором она использовалась, подождите минут 5, ~~иначе будет вылет~~ уже не будет, но лучше минутку подождать
- Если все таки вылетел киппер, все зависло - в папке с плагинами будет файлик с логом ошибки(`panic_tcp.log`), кидаете его мне
